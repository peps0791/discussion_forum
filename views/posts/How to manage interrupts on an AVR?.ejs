<html>
	<head>
		<link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
		<script src="https://code.jquery.com/jquery-3.2.1.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="  crossorigin="anonymous"></script>
		<script src = "/jquery-highlight.js"></script>
		<link href="/jquery.upvote.css" rel="stylesheet">
		<script src = "/jquery.upvote.js" type="text/javascript"></script>
		<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
		<link rel="stylesheet" href="/style.css"/>
		<script src="/createlinks.js"></script>
		<script src="/textaudit.js"></script>
		<script src="/PorterStemmer1980.min.js"></script>
		<script src="/highlight.js"></script>
		<title id = 'pagetitle'>How to manage interrupts on an AVR?
		</title>
	</head>
	<body id = 'pagebody'>
		<div id = "loginmodals"></div>
		<div id = "issuemodals"></div>
		<div id = "highlight_tool"></div>
		<div id = "reward_tool"></div>
		<div id = "comment_tool"></div>
		<div class = "container">
			<header>
				<h1>Just Another Discussion Forum</h1>
			</header>
			<div class="topnav" id="myTopnav">
				<a href="/home">Home</a>
				<a href = "#issueModal" data-toggle="modal" style = "float:right">Report Issue</a>
			</div>
			<div class = "content">
			<div id = "ques-99" class = "post">
			<h2>Question</h2>
			<div id="vote-99" class="upvote" style="float:left;">
				<a class="upvote"></a>
				<span class="count">5</span>
				<a class="downvote"></a>
				<a class="star"></a>
				<p>Views :: 2471</p>
			</div>
			<form id = "questionpostsform" method="GET" action = "/ask">
				<input type="submit" id = "quesbtn" class="btn btn-primary btn-lg" value="Ask Question">
			</form>
				<h2>How to manage interrupts on an AVR?</h2>
<p>I have a number of interrupt service routines on an <a href="https://en.wikipedia.org/wiki/Atmel_AVR" rel="nofollow">AVR</a>. These include interrupts for <a href="https://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter#Synchronous_transmission" rel="nofollow">USART</a> serial communication, timers, and <a href="http://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus" rel="nofollow">SPI</a> communication.</p>

<p>For all of these, I use circular queues (using a start and end pointer, without boundary checking).</p>

<p>Some problems start to occur if the AVR starts to get overloaded. The circular queues will lose chunks of data. To solve this, I can reduce the load on the AVR (for example, by skipping some cycles in the timer). However, this is a manual process, where it is reduced if the AVR appears to have problems. This is partly because I do want relatively consistent timer periods.</p>

<p>However, even at 70% average processor load, the queues can fill up randomly by chance.</p>

<p>In case of spurious overloading at times, how can I make this more adaptive to avoid queue overflows?</p>

			</div>
			<div class = "userinfosection"  id = "userinfo-99" data-toggle = "popover">
				<p>user name : ronalchn</p>
				<p> user reputation : 2449</p>
				<p class = "tagcontent" id = "usertaginfo-99">{'None': 187, 'two-wheeled': 20, 'inverse-kinematics': 15, 'interrupts': 5, 'microcontroller': 13, 'wiring': 7, 'c': 8, 'avr': 5, 'brushless-motor': 2, 'joint': 15, 'kinematics': 15, 'hall-sensor': 2, 'mobile-robot': 20, 'arm': 15}</p>
			</div><br>
			<br><h3>Comments</h3>
				<button data-toggle = 'collapse' data-target = "#commentsection-99">Load Comments</button></br>
			<div id = "commentsection-99" class = 'collapse'>
			<div id = "comment-106" class = "comment">
				<p>I wonder whether this question isn't more suited to the StackOverflow site, than Robotics?</p>
			</div>
			<div id = "comment-112" class = "comment">
				<p>Defiantly a StackOverflow question with the embedded tag.</p>
			</div>
			<div id = "comment-124" class = "comment">
				<p>If we are going to try to shunt this off to another site then it would be more appropriate to Programmers Stack Exchange than Stack Overflow as it is a concepts question. As it is, since answers to this with relation to robotics would be different to this question on a non robotic context, I think it's fine here.</p>
			</div>
			<div id = "comment-147" class = "comment">
				<p>Guys please stop saying that robot programming questions do not relate to this. cause they do. Believe it or not if you ask this on stackoverflow, you won't get any answer. cause programmers over there hardly know anything about interrupts or avr programming.. Please if you don't know the answer, just go to another question instead of down-voting or voting to close. Thank You. Lets keep the community living.!</p>
			</div>
			<div id = "comment-177" class = "comment">
				<p>What model AVR? Have you considered running [FreeRTOS](http://www.freertos.org/)? It provides built in queue management, and the ability to dynamically prioritize tasks in response to load.</p>
			</div>
			<div id = "comment-178" class = "comment">
				<p>@Crake Depending on the application, even something like FreeRTOS might be OTT... but +1 for the suggestion.</p>
			</div>
			<div id = "comment-196" class = "comment">
				<p>I just checked, FreeRTOS does not support most AVRs, an OS is overkill for a slow MC anyways (up to 20MHz).</p>
			</div>
			<div id = "comment-305" class = "comment">
				<p>As an active SO and electronics.SE member, I wonder why this question is specifically asked here under Robotics. Anyone who has done bare-metal (embedded) programming would have dealt with such problems.</p>
			</div>
			<div id = "comment-344" class = "comment">
				<p>@icarus74 - People ask where they ask, what we have to decide is whether these questions are on topic here. Currently the general [consensus seems to be yes](http://meta.robotics.stackexchange.com/q/5/37) we should be tolerant and only migrate if they are actually *off-topic* here.</p>
			</div>
			</div>
				<textarea id = "speech-99" rows="3" cols="80"></textarea><br>
				<button class="record-start" id="start-99">
					<img id="start_img-99" src="/mic.gif" alt="Start">
				</button>
				<button class = "comment-btn" id = "comment-btn-99">Comment</button>

<h1>Answers</h1>
			<br><div id = "ans-169"  class = "post">
				<h2>Answer</h2>
			<div id="vote-169" class="upvote" style="float:left;">
				<a class="upvote"></a>
				<span class="count">3</span>
				<a class="downvote"></a>
				<a class="star"></a>
			</div>
				<p><p>I can't answer specifically for the AVR, but I can offer some more general advice.</p>

<h3>Low level</h3>

<p>I think you are going to have to <strong>prioritise</strong>. Look at what you can afford to throw away and what you can afford to process when your system starts to get overloaded. Also, profile your usage to see what data you have coming in when.</p>

<p>For instance, if you have a higher level retry protocol on your serial comms, then when you are overloaded perhaps you could drop incoming serial bytes, leaving it to the retry mechanism to catch up when the CPU has the time.</p>

<p>If you can do this then you are going to want to fail early. When your serial buffer is full, there is no point reading the data from the uart, writing it into your buffer, overwriting existing data - that's just wasting cycles which could be used elsewhere (you are going to have to throw away the partial serial stream anyway). When you experience a serial buffer overrun, just clear the uart without reading it, leave the buffer in it's old state and return, letting the CPU get on with things it can complete successfully.</p>

<p>Alternatively, you could disable interrupts entirely for low priority events.</p>

<p>Profiling your usage can also be very valuable. Lets say you have four 16 byte buffers where one is constantly going into an overrun condition because you are sending 36 byte packets to it, but where the other 3 never have more than 5 or 6 bytes in them at once. In this case it is worth rewriting your buffer code to allow different sized buffers. That way you could allocate 8 bytes each to three streams and 40 bytes for the final stream.</p>

<h3>High level</h3>

<p>You need to analyse <em>why</em> your buffers <em>randomly fill up by chance</em>. Are you trying to do too much with the data in one go? Could you split that processing up and do several shorter processes rather than one long process.</p>

<p>For instance, if your interrupts normally take up 70% of your CPU and another routine takes up 20% <em>on average</em>, but only needs 10% some of the time and runs out of CPU at others, then breaking up that processing into more predictable, repeatable blocks could be worthwhile, even if it takes more processing power power overall.</p>

<p>Also, if you don't have a higher level retry mechanism, consider implementing one, this would enable low level prioritisation which might otherwise not be possible.</p>

<p>Finally, learn how to optimise for your hardware. Again, profiling can help here. If your ISRs are taking up a significant proportion of your CPU time, every cycle you save is a cycle you can use elsewhere. Don't blindly 'optimise' everywhere, chose your battles. </p>

<p>Profiling will tell you where in your code is most critical so you can put your efforts where it will count (See <a href="https://softwareengineering.stackexchange.com/a/99463/22493">Is micro-optimisation important when coding?</a>).</p>
</p><br>
			</div>
			<div class = "userinfosection"  id = "userinfo-169" data-toggle = "popover">
				<p>user name : Mark Booth</p>
				<p> user reputation : 3037</p>
				<p class = "tagcontent" id = "usertaginfo-169">{'control': 7, 'quadcopter': 2, 'None': 258, 'tuning': 7, 'uav': 2, 'design': 2, 'stepper-motor': 7}</p>
			</div><br><h3>Comments</h3><p>no comments yet<p><br>
			<div id = "commentsection-169" class = 'collapse'>
			</div>
				<textarea id = "speech-169" rows="3" cols="80"></textarea><br>
				<button class="record-start" id="start-169">
					<img id="start_img-169" src="/mic.gif" alt="Start">
				</button>
				<button class = "comment-btn" id = "comment-btn-169">Comment</button>
			<br><div id = "ans-179"  class = "post">
				<h2>Answer</h2>
			<div id="vote-179" class="upvote" style="float:left;">
				<a class="upvote"></a>
				<span class="count">2</span>
				<a class="downvote"></a>
				<a class="star"></a>
			</div>
				<p><p>First, all processors have limited performance. So the effect could be that the performance is just not good enough for the amount of work you have to do.</p>

<p>The average load is pretty uninteresting for diagnosing lost interrupts. The interesting thing is how many interrupts and therefore how much load on the interrupt service routines are there in peak situations. If the interrupts cause too much calculation that is needed to be done in a fixed amount of time then you need a faster CPU.</p>

<p>With little computing in the ISR and a big buffer, these peaks can be flattened out, but this introduces a delay. If you can decrease the amount of data written into the buffer then a bit more processing in the ISR could pay off.</p>

<p>If your solution is to skip the unimportant(?) processing in the main routine, then you should put more processing into the ISRs. This way the CPU load will go to the ISRs and the main routine will get less. The problem here is that if the processing of one interrupt is ongoing, the next interrupt will be delayed, as its ISR can only run after finishing the other ISR. If this delay is too long then the interrupt will get lost.</p>

<p>So choose the way that is best fitted for your solution. But be aware that: "The only replacement for CPU power is CPU power."</p>
</p><br>
			</div>
			<div class = "userinfosection"  id = "userinfo-179" data-toggle = "popover">
				<p>user name : Lars P tter</p>
				<p> user reputation : 121</p>
				<p class = "tagcontent" id = "usertaginfo-179">{'None': 2}</p>
			</div><br><h3>Comments</h3>
				<button data-toggle = 'collapse' data-target = "#commentsection-179">Load Comments</button></br>
			<div id = "commentsection-179" class = 'collapse'>
			<div id = "comment-368" class = "comment">
				<p>I once worked on a robot with a forth microcontroller, swapping it for another wasn't economically viable, we had squeezed every last ounce of performance out of it and it still wasn't fast enough for some new features we needed. We discovered though that 80% of the chips would run 20% overclocked and this gave us the performance we needed, so we bought twice as many as we needed and screened out the failures. We never had a single warranty return due to CPU failure and it saved us a whole bunch or redevelopment. *8')</p>
			</div>
			<div id = "comment-404" class = "comment">
				<p>Thank you for your answer. My current solution is just to limit the rate at which data is gathered (it is doing analog DAQ, but doing trigonometry, implementing a smoothing filter at the same time, and differentiating - a Savitzky-Golay filter). There may come a time when I won't need to do it anymore - we are planning on getting encoders which won't have the kind of noise which made smoothing necessary.</p>
			</div>
			</div>
				<textarea id = "speech-179" rows="3" cols="80"></textarea><br>
				<button class="record-start" id="start-179">
					<img id="start_img-179" src="/mic.gif" alt="Start">
				</button>
				<button class = "comment-btn" id = "comment-btn-179">Comment</button>
			<br><div id = "ans-224"  class = "post">
				<h2>Answer</h2>
			<div id="vote-224" class="upvote" style="float:left;">
				<a class="upvote"></a>
				<span class="count">8</span>
				<a class="downvote"></a>
				<a class="star"></a>
			</div>
				<p><p>It sounds like you're observing the symptom of "lost bytes". There are several different things that can cause an AVR to lose bytes.</p>

<p>It sounds like you are <em>guessing</em> that it's losing bytes when new bytes are coming in while the buffer is full. While there are several remedies to fix or at least ameliorate that particular problem, those approaches are useless and counter-productive if the real cause of the "lost bytes" is something else.</p>

<p>The first thing I would do in your shoes is to set up some sort of "status debug" port that gives me a clue of why exactly bytes have been lost -- at least a status LED. Once you know why bytes are being lost, you can apply the appropriate remedy.</p>

<p>Most modern protocols have some sort of check value at the end of each packet.
It's nice if your status debug system can report on the packet goodput rate and the packet error rate -- at least blink a green LED for each validated packet and a red LED for each failed packet check.</p>

<p>Since (especially with radio connections) the occasional corrupted byte is pretty much inevitable, most modern protocols are carefully designed such that if <em>any</em> byte is corrupted or lost, the system will eventually discard that packet, and eventually re-sync and correctly handle future packets.</p>

<h2>Bytes lost because the interrupt handler somehow never put them into the buffer</h2>

<p>Often bytes are lost because the interrupt handler somehow never put them into the buffer. There are several causes, each with a different remedy: external problems, and internal interrupts turned off too long.</p>

<p><strong>External problems</strong>:</p>

<ul>
<li>Line noise causing errors</li>
<li>Physical wired connections accidentally getting temporarily unplugged</li>
<li>Loss of signal on radio connections</li>
</ul>

<p>Typically we clip an oscilloscope to the input pin and -- if we're lucky -- we can see the problem and try various techniques to see if that cleans up the signal.</p>

<p>Even when the signal at the input pin looks perfect, we can still have data loss issues.</p>

<p>Immediately after the last bit of a byte comes in a <a href="https://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter#Synchronous_transmission" rel="nofollow noreferrer">USART</a> or <a href="http://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus" rel="nofollow noreferrer">SPI</a> port,
normally the interrupt handler for that port is triggered, and that interrupt handler pulls that byte and sticks it into a circular buffer. However, if the <strong>interrupts are turned off too long</strong>, the next byte to come in that port will inevitably overwriting and losing the first byte -- the interrupt handler for that port never sees that first byte. The four "ways an interrupt handler can be turned off too long" are listed at <a href="https://electronics.stackexchange.com/questions/35835/what-can-be-the-cause-of-an-exceptionally-large-latency-for-the-uart-receive-int/44779#44779">"What can be the cause of an exceptionally large latency for the UART receive interrupt?"</a>.</p>

<p>To fix this problem, you need to get the longest time an interrupt handler is ever turned off to be less than the time to transfer one character. So you must either</p>

<ul>
<li>Reduce the amount of time interrupts are turned off; or</li>
<li>Slow down the communication bit rate to increase the time to transfer one character;</li>
<li>Or both.</li>
</ul>

<p>It's very tempting to write the interrupt routine such that, immediately after it puts a byte into the circular buffer, the same interrupt routine then checks to see if it's a complete packet and, if so, completely parse and handle it. Alas, parsing usually takes so long that any further bytes coming in the same or any other port are lost.</p>

<p>We typically fix this by reducing each interrupt handler (and therefore the time interrupts are disabled while processing this handler) to the minimum possible to grab a byte and stick it in the circular buffer and return from interrupt.
All the packet-parsing and packet-handling stuff executes with interrupts enabled.</p>

<p>The simplest way is for the main loop (AKA the "background task") to periodically
call a function that checks if there is a complete packet in the circular buffer,
and if so parse and handle it. Other more complex approaches involve second-level interrupt handlers, <a href="http://www.nongnu.org/avr-libc/user-manual/group__avr__interrupts.html" rel="nofollow noreferrer">nested interrupts</a>, etc.</p>

<p>However, even when the interrupt handler perfectly receives every byte and correctly puts it into the buffer, sometimes a system can still lose bytes from buffer overflow:</p>

<h2>Bytes lost from buffer overflow</h2>

<p>Many people write packet handlers that don't do anything until the handler sees a complete packet in the buffer -- then the handler processes the entire packet as a whole. That approach overflows the buffer and data is lost if any incoming packet is larger than you are expecting, too big to fit in the buffer -- <strong>single-packet overflow</strong>.</p>

<p>Even if your buffer is plenty big enough to hold the largest possible packet, sometimes during the time you're processing <em>that</em> packet, the next packet is so large that it overflows the circular queue before your packet-handler gets around to removing the first packet from the queue to make room for future packets -- <strong>two-packet overflow</strong>.</p>

<p>Is there some way your status debug system could detect and signal if a byte comes in and it has to be thrown away because there's no more room in the queue?
The simple solution to both these problems is to increase the size of the buffer to hold at least two maximum-size packets, or somehow change the thing that's sending the packets to send smaller packets -- so two packets will fit in the space you have now.</p>

<p>Sometimes incoming data fills the buffers faster than the packet handler can pull data out of the buffer. Increasing the size of the buffer only briefly delays the problem, and sending smaller packets (but more of them) will probably only make things worse. A real-time system <em>must</em> process incoming data at least as fast as that data can come in; otherwise the <strong>processor overload</strong> will only make the processor get further and further behind. Is there some way your status debug system could detect and signal this sort of overflow?</p>

<p>If this overflow only happens rarely, perhaps the simplest "solution" (arguably merely a hack) is to handle it in more-or-less the same way you would handle a (hopefully rare) power glitch or loss-of-signal on a radio connection: when an overflow is detected, have the AVR erase the entire buffer and pretend it never received those bytes. Most modern protocols are carefully designed such that, if any packet is lost, the system will eventually re-sync and correctly handle future packets.</p>

<p>To really fix this problem requires somehow making the "time to process a packet" less than "time from the end of one packet to the end of the next packet".
so you must either</p>

<ul>
<li>Reduce the bit rate.</li>
<li>Modify the sender to give the AVR more time to process a packet -- perhaps unconditionally send 50 additional "dummy bytes" in the packet preamble -- or however many is needed to give the AVR more than enough time to completely process the last packet and get ready for the next packet.</li>
<li>Decrease the time to process a packet</li>
<li>Or some combination.</li>
</ul>

<p>The wall-clock time to process a packet involves both the time the AVR spends in actually processing the packet, and also the time the AVR spends doing "other stuff" such as dealing with all the <em>other</em> I/O ports and interrupt handlers.</p>

<p>Some methods of decreasing the time to actually process a packet are:</p>

<ul>
<li>Sometimes it's faster to copy the packet out of the queue into some other buffer for further processing, removing it from the circular queue. It makes the packet-handler simpler if the packet starts at the beginning of that other buffer, so key parts of the packet are a fixed constant offset from the beginning of that buffer. (This has the advantage of making it impossible for the serial interrupt handler, which only writes into the circular queue, to accidentally corrupt that packet after it's been copied to that other buffer.) (This approach lets you use tested and "optimized" and known-good functions that handle numbers represented as <a href="http://en.wikipedia.org/wiki/ASCII" rel="nofollow noreferrer">ASCII</a> strings of hex digits or decimal digits in consecutive order, which may run faster operating on that linear buffer than "equivalent" functions that also have to deal with the wrap-around split of a circular buffer). This requires both the queue and the other buffer to each be at least the size of the maximum possible packet.</li>
<li>Sometimes it's faster to leave the packet in the queue while parsing it and remove it from the queue only after the packet handler is completely done with it.</li>
<li>Sometimes a pair of "ping-pong" buffers is faster than a circular queue.</li>
<li>Many systems use only a single buffer large enough for the largest possible valid packet, and completely disable interrupts from that port until the interrupt handler has finished with the last packet and is ready for the next packet.</li>
<li>Somehow actually do less work per packet.</li>
</ul>

<p>More general approaches to dealing with situations where "other stuff" is eating so much time that there's not enough time to deal with the packet in the buffer (and may also help reduce the time to actually process the packet):</p>

<ul>
<li>If you're lucky, you can find some algorithmic tweaks to effectively do the same work in fewer cycles.</li>
<li>Load-shedding: do less important stuff less often; or perhaps don't do them at all in times of heavy load. (As implemented in the <a href="http://en.wikipedia.org/wiki/Apollo_Guidance_Computer#PGNCS_trouble" rel="nofollow noreferrer">Apollo 11 AGC</a>).</li>
<li>yield() more often: if your main loop does fair round-robin cycling between "if we have a complete packet from port 1, handle it" and "if we have a complete packet from port 2, handle it", and the packet parser for either one takes so long that the buffer for the <em>other</em> port overflows, it may help to break the packet parser up into shorter pieces and do only a little processing each time through the main loop, giving the <em>other</em> packet parser a chance to deal with packets before its buffer overflows. Perhaps even consider switching to a pre-emptive task scheduler or a full-up RTOS.</li>
<li>yield() less often: sometimes a processor spends more time in "task switching" or "multitasking overhead" than actually doing anything productive.</li>
<li>Reduce the time spent processing interrupt handlers. (<a href="http://www.cs.utah.edu/~regehr/papers/lctes05/regehr-lctes05.pdf" rel="nofollow noreferrer">Preventing Interrupt Overload</a> ). High-frequency pulses on one interrupt line can pause main loop tasks indefinitely. It may be necessary to program each low-priority interrupt handler to recognize high-load situations and completely disable its own particular interrupt before re-enabling global interrupts at its return-from-interrupt instruction, and have the main loop recognize low-load situations and re-enable those interrupts.</li>
<li>Increase the clock rate of the processor.</li>
<li>Switch to a more powerful processor. A "more powerful" processor is <em>not</em> the same as "a processor with a faster clock rate". You might be able to find a processor that does the same work in <em>fewer</em> cycles than your particular 8-bit AVR -- perhaps some other AVR with specialized peripherals that do work in hardware that you're currently doing in software, freeing up software cycles for other things; or perhaps a 32-bit processor that can do certain tasks in software in fewer cycles than any 8-bit processor.</li>
<li>Occasionally in robotics "one big fast processor" is better than lots of little processors: the amount of code and the communication latency to copy a message from one task to another task on the same processor is always much less than to copy that same message from one task to another task on some other processor.</li>
<li>Often in robotics it makes things simpler and more "provably correct" to add more processors, perhaps one processor per leg or even <a href="http://openservo.com" rel="nofollow noreferrer">one processor per servo</a>. If you have one task per processor, then many of the above potential problems can't ever happen.</li>
</ul>
</p><br>
			</div>
			<div class = "userinfosection"  id = "userinfo-224" data-toggle = "popover">
				<p>user name : David Cary</p>
				<p> user reputation : 3365</p>
				<p class = "tagcontent" id = "usertaginfo-224">{'quadcopter': 38, 'stepper-driver': 9, 'None': 256, 'multi-rotor': 2, 'force-sensor': 9, 'stability': 36, 'industrial-robot': 1, 'design': 18, 'motor': 2, 'stepper-motor': 9}</p>
			</div><br><h3>Comments</h3>
				<button data-toggle = 'collapse' data-target = "#commentsection-224">Load Comments</button></br>
			<div id = "commentsection-224" class = 'collapse'>
			<div id = "comment-295" class = "comment">
				<p>Excellent answer David, puts my more general answer to shame. *8') I especially like the gem of advice in the middle which recommends not trying to parse a packet in your interrupt service routine, a mistake that it's easy to make when starting out.</p>
			</div>
			<div id = "comment-363" class = "comment">
				<p>@MarkBooth: Thank you for the praise.</p>
			</div>
			</div>
				<textarea id = "speech-224" rows="3" cols="80"></textarea><br>
				<button class="record-start" id="start-224">
					<img id="start_img-224" src="/mic.gif" alt="Start">
				</button>
				<button class = "comment-btn" id = "comment-btn-224">Comment</button>
			</div>
			<div id = "resourcestab" class = "resourcestab">
				<ul class="nav nav-tabs">
					<li class="active"><a data-toggle="tab" href="#resources">Resources</a></li>
					<li><a data-toggle="tab" href="#highlights">Highlights</a></li>
				</ul>
					<div class="tab-content">
						<div id="resources" class="tab-pane fade in active">
							<h3>Links from the Page</h3>
							<div id = "resourcescontent"></div>
						</div>
						<div id="highlights" class="tab-pane fade">
							<h3>Highlights</h3>
							<div id = "highlightcontent"></div>
						</div>
			</div>
			</div>
			<footer>Moore & Peps collaboration.</footer>
	</div>
	<script src="/post.js"></script>
	<script type="text/javascript">
		$("#loginmodals").load("/loginModal.html");
		$("#issuemodals").load("/issueModal.html");
		$("#highlight_tool").load("/highlight_tool.html");
		$("#comment_tool").load("/comment_tool.html");
		$("#reward_tool").load("/reward_tool.html");
		checkLoggedInUser()
		var content = $('.content').html();
		populateResources(content)
		getHighlights()
		setOnLinksHover()
	</script>
	<script src="/media.js"></script>
	<script src="/vote.js"></script>
	<script src="/managefunction.js"></script>
	</body>
</html>